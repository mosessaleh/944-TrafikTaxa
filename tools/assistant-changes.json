{
  "description": "Implement email verification flow without DB: signed JWT token + Resend (if configured) or dev link. Persist session via 'me' cookie.",
  "files": [
    {
      "path": ".env.example",
      "content": "AUTH_SECRET=change-me\nPUBLIC_BASE_URL=http://localhost:3000\nRESEND_API_KEY=\nRESEND_FROM=944 Trafik <no-reply@944.dk>\n"
    },
    {
      "path": "lib/jwt.ts",
      "content": "import crypto from 'crypto';\n\nfunction b64url(input: string | Buffer): string {\n  const base = (input instanceof Buffer ? input : Buffer.from(String(input))).toString('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/g, '');\n  return base;\n}\n\nexport function signJWT(payload: Record<string, any>, secret: string, expiresInSec: number): string {\n  const header = { alg: 'HS256', typ: 'JWT' };\n  const now = Math.floor(Date.now() / 1000);\n  const body = { iat: now, exp: now + expiresInSec, ...payload };\n  const encHeader = b64url(JSON.stringify(header));\n  const encPayload = b64url(JSON.stringify(body));\n  const data = `${encHeader}.${encPayload}`;\n  const sig = crypto.createHmac('sha256', secret).update(data).digest('base64')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=+$/g, '');\n  return `${data}.${sig}`;\n}\n\nexport function verifyJWT(token: string, secret: string): { valid: boolean; payload?: any; error?: string } {\n  try {\n    const parts = token.split('.');\n    if (parts.length !== 3) return { valid: false, error: 'Malformed token' };\n    const [encHeader, encPayload, signature] = parts;\n    const data = `${encHeader}.${encPayload}`;\n    const expected = crypto.createHmac('sha256', secret).update(data).digest('base64')\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=+$/g, '');\n    if (signature !== expected) return { valid: false, error: 'Bad signature' };\n    const payloadJson = Buffer.from(encPayload.replace(/-/g, '+').replace(/_/g, '/'), 'base64').toString('utf8');\n    const payload = JSON.parse(payloadJson);\n    const now = Math.floor(Date.now() / 1000);\n    if (typeof payload.exp === 'number' && now > payload.exp) return { valid: false, error: 'Expired' };\n    return { valid: true, payload };\n  } catch (e: any) {\n    return { valid: false, error: e?.message || 'Invalid token' };\n  }\n}\n"
    },
    {
      "path": "lib/mail.ts",
      "content": "export async function sendVerificationEmail(email: string, verifyUrl: string): Promise<{ sent: boolean; reason?: string }>{\n  const key = process.env.RESEND_API_KEY;\n  const from = process.env.RESEND_FROM || 'no-reply@944.dk';\n  if (!key) {\n    console.log('[dev-mail] To:', email, 'Verify:', verifyUrl);\n    return { sent: false, reason: 'RESEND_API_KEY not configured' };\n  }\n  const res = await fetch('https://api.resend.com/emails', {\n    method: 'POST',\n    headers: { 'Authorization': `Bearer ${key}`, 'Content-Type': 'application/json' },\n    body: JSON.stringify({ from, to: email, subject: 'Verify your email', html: `<p>Hej! Klik <a href=\"${verifyUrl}\">her</a> for at bekr√¶fte din e-mail.</p>` })\n  });\n  if (!res.ok) {\n    const text = await res.text().catch(() => '');\n    console.error('[resend error]', res.status, text);\n    return { sent: false, reason: `Resend error ${res.status}` };\n  }\n  return { sent: true };\n}\n"
    },
    {
      "path": "lib/sanitize.ts",
      "content": "export function normalizeInput(input: string): string {\n  if (typeof input !== 'string') return '';\n  try { return input.normalize('NFC'); } catch { return input; }\n}\nfunction stripUnsafeCore(s: string): string { return s.replace(/[\\p{Cc}\\p{Cs}<>]/gu, ''); }\nexport function sanitizeName(input: string): string { const s = normalizeInput(input); return stripUnsafeCore(s).replace(/[^\\p{L}\\p{M}\\s\\-'.]/gu, '').trim(); }\nexport function sanitizeAddress(input: string): string { const s = normalizeInput(input); return stripUnsafeCore(s).trim(); }\n"
    },
    {
      "path": "lib/validation.ts",
      "content": "import { z } from 'zod';\nexport const nameRegex = /^[\\p{L}\\p{M}\\s\\-'.]+$/u;\nexport const addressRegex = /^[^\\p{Cc}\\p{Cs}<>]+$/u;\nexport const UserRegisterSchema = z.object({\n  firstName: z.string({ required_error: 'Required' }).min(2, 'First name is too short').regex(nameRegex, 'First name contains invalid characters'),\n  lastName: z.string().min(2, 'Last name is too short').regex(nameRegex, 'Last name contains invalid characters').optional(),\n  phone: z.string({ required_error: 'Required' }).min(6, 'Phone is too short'),\n  address: z.string({ required_error: 'Required' }).min(3, 'Address is too short').regex(addressRegex, 'Address contains invalid characters'),\n  city: z.string().regex(nameRegex, 'City contains invalid characters').optional().nullable().transform(v => (v ?? undefined)),\n  postcode: z.string().max(10, 'Postcode is too long').optional().nullable().transform(v => (v ?? undefined)),\n  email: z.string().email('Invalid email').optional(),\n  password: z.string().min(8, 'Password is too short').optional()\n});\nexport const RegisterSchema = UserRegisterSchema;\nexport type RegisterInfer = z.infer<typeof UserRegisterSchema>;\n"
    },
    {
      "path": "app/api/auth/register/route.ts",
      "content": "import { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { RegisterSchema } from '@/lib/validation';\nimport { sanitizeName, sanitizeAddress, normalizeInput } from '@/lib/sanitize';\nimport { signJWT } from '@/lib/jwt';\nimport { sendVerificationEmail } from '@/lib/mail';\n\nfunction getBaseUrl(req: NextRequest){\n  const env = process.env.PUBLIC_BASE_URL;\n  if (env) return env.replace(/\\/$/, '');\n  try { const url = new URL(req.url); return `${url.protocol}//${url.host}`; } catch { return 'http://localhost:3000'; }\n}\n\nfunction mapBody(body:any){\n  const b = { ...body };\n  if (!b.address && typeof b.street === 'string') b.address = b.street;\n  for (const k of ['firstName','lastName','city','address']) if (typeof b[k] === 'string') b[k] = normalizeInput(b[k]);\n  if (typeof b.firstName === 'string') b.firstName = sanitizeName(b.firstName);\n  if (typeof b.lastName === 'string') b.lastName = sanitizeName(b.lastName);\n  if (typeof b.city === 'string') b.city = sanitizeName(b.city);\n  if (typeof b.address === 'string') b.address = sanitizeAddress(b.address);\n  return b;\n}\n\nexport async function POST(req: NextRequest){\n  try {\n    const raw = await req.json();\n    const body = mapBody(raw);\n    const data = RegisterSchema.parse(body);\n\n    const secret = process.env.AUTH_SECRET || 'dev-secret';\n    const base = getBaseUrl(req);\n\n    // Token carries minimal info; user creation can be deferred until verify\n    const token = signJWT({ email: data.email || '', firstName: data.firstName || '', address: data.address || '' }, secret, 60 * 60); // 1h\n    const verifyUrl = `${base}/api/auth/verify?token=${encodeURIComponent(token)}`;\n\n    const mail = data.email ? await sendVerificationEmail(String(data.email), verifyUrl) : { sent: false };\n\n    // In many systems, the record is created after email verification; keeping it stateless for now.\n    const payload: any = { ok: true, message: mail.sent ? 'Verification email sent' : 'Dev mode: use verifyUrl', verifyUrl: mail.sent ? undefined : verifyUrl };\n    return NextResponse.json(payload, { status: 201 });\n  } catch (err: any) {\n    if (err?.issues) {\n      const errors: Record<string,string> = {};\n      for (const i of err.issues) {\n        const key = Array.isArray(i.path) && i.path[0] ? String(i.path[0]) : 'form';\n        errors[key] = i.message;\n      }\n      return NextResponse.json({ ok:false, errors }, { status: 422 });\n    }\n    return NextResponse.json({ ok:false, message: 'Unexpected error' }, { status: 500 });\n  }\n}\n"
    },
    {
      "path": "app/api/auth/verify/route.ts",
      "content": "import { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { verifyJWT } from '@/lib/jwt';\n\nexport async function GET(req: NextRequest){\n  const url = new URL(req.url);\n  const token = url.searchParams.get('token') || '';\n  const secret = process.env.AUTH_SECRET || 'dev-secret';\n  const { valid, payload, error } = verifyJWT(token, secret);\n  if (!valid || !payload) {\n    return NextResponse.json({ ok:false, message: 'Invalid or expired token', error }, { status: 400 });\n  }\n\n  const user = {\n    id: Date.now(),\n    email: String(payload.email || ''),\n    firstName: String(payload.firstName || ''),\n    lastName: '',\n    role: 'USER',\n    emailVerified: true\n  };\n\n  const res = NextResponse.json({ ok:true, user });\n  // Session cookie consumed by lib/session.ts\n  res.cookies.set('me', encodeURIComponent(JSON.stringify(user)), {\n    httpOnly: true,\n    sameSite: 'lax',\n    secure: process.env.NODE_ENV === 'production',\n    path: '/'\n  });\n  return res;\n}\n"
    }
  ]
}
